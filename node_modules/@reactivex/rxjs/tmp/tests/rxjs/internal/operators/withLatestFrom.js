"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var userFunction_1 = require("rxjs/internal/util/userFunction");
var from_1 = require("../create/from");
var MutableSubscriber_1 = require("rxjs/internal/MutableSubscriber");
var noop_1 = require("rxjs/internal/util/noop");
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * ![](withLatestFrom.png)
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * ## Example
 * On every click event, emit an array with the latest timer event plus the click event
 * ```javascript
 * const clicks = fromEvent(document, 'click');
 * const timer = interval(1000);
 * const result = clicks.pipe(withLatestFrom(timer));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var otherSources = (args && args.length === 1 && Array.isArray(args[0]))
        ? args[0]
        : args;
    return function (source) { return source.lift(withLatestFromOperator(otherSources)); };
}
exports.withLatestFrom = withLatestFrom;
function withLatestFromOperator(otherSources) {
    return function withLatestFromLifted(source) {
        var mut = this;
        var _allHaveValues = false;
        var len = otherSources.length;
        var _cache = new Array(len);
        var _hasValue = 0;
        var _loop_1 = function (i) {
            var result = userFunction_1.tryUserFunction(from_1.from, [otherSources[i]]);
            if (userFunction_1.resultIsError(result)) {
                mut.error(result.error);
                return { value: mut.subscription };
            }
            else {
                var first_1 = true;
                var innerMut = new MutableSubscriber_1.MutableSubscriber(function (value) {
                    if (!_allHaveValues && first_1) {
                        first_1 = false;
                        _hasValue++;
                        _allHaveValues = _hasValue === len;
                    }
                    _cache[i] = value;
                }, mut.error, noop_1.noop);
                mut.subscription.add(result.subscribe(innerMut));
            }
        };
        for (var i = 0; i < len && !this.closed; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        var _next = mut.next;
        mut.next = function (value) {
            if (_allHaveValues) {
                _next([value].concat(_cache));
            }
        };
        return source.subscribe(mut);
    };
}
//# sourceMappingURL=withLatestFrom.js.map