"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var operators_1 = require("rxjs/operators");
var rxjs_1 = require("rxjs");
var testing_1 = require("rxjs/testing");
var assertDeepEquals_1 = require("../test_helpers/assertDeepEquals");
/** @test {retry} */
describe('retry operator', function () {
    var testScheduler;
    beforeEach(function () {
        testScheduler = new testing_1.TestScheduler(assertDeepEquals_1.assertDeepEquals);
    });
    // asDiagram('retry(2)')
    it('should handle a basic source that emits next then errors, count=3', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = cold('--1-2-3-#');
            var subs = ['^       !                ',
                '        ^       !        ',
                '                ^       !'];
            var expected = '--1-2-3---1-2-3---1-2-3-#';
            var result = source.pipe(operators_1.retry(2));
            expectObservable(result).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    it('should retry a number of times, without error, then complete', function (done) {
        var errors = 0;
        var retries = 2;
        new rxjs_1.Observable(function (observer) {
            observer.next(42);
            observer.complete();
        }).pipe(operators_1.map(function (x) {
            if (++errors < retries) {
                throw 'bad';
            }
            errors = 0;
            return x;
        }), operators_1.retry(retries)).subscribe({
            next: function (x) {
                chai_1.expect(x).to.equal(42);
            },
            error: function (err) {
                chai_1.expect('this was called').to.be.true;
            },
            complete: done,
        });
    });
    it('should retry a number of times, then call error handler', function (done) {
        var errors = 0;
        var retries = 2;
        new rxjs_1.Observable(function (observer) {
            observer.next(42);
            observer.complete();
        }).pipe(operators_1.map(function (x) {
            errors += 1;
            throw 'bad';
        }), operators_1.retry(retries - 1)).subscribe({
            next: function (x) {
                chai_1.expect(x).to.equal(42);
            },
            error: function (err) {
                chai_1.expect(errors).to.equal(2);
                done();
            },
            complete: function () {
                chai_1.expect('this was called').to.be.true;
            },
        });
    });
    it('should retry until successful completion', function (done) {
        var errors = 0;
        var retries = 10;
        new rxjs_1.Observable(function (observer) {
            observer.next(42);
            observer.complete();
        }).pipe(operators_1.map(function (x) {
            if (++errors < retries) {
                throw 'bad';
            }
            errors = 0;
            return x;
        }), operators_1.retry(), operators_1.take(retries)).subscribe({
            next: function (x) {
                chai_1.expect(x).to.equal(42);
            },
            error: function (err) {
                chai_1.expect('this was called').to.be.true;
            },
            complete: done,
        });
    });
    it('should handle an empty source', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = cold('|');
            var subs = '(^!)';
            var expected = '|';
            var result = source.pipe(operators_1.retry());
            expectObservable(result).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    it('should handle a never source', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = cold('-');
            var subs = '^';
            var expected = '-';
            var result = source.pipe(operators_1.retry());
            expectObservable(result).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    it('should return a never observable given an async just-throw source and no count', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = cold('-#'); // important that it's not a sync error
            var unsub = '                                     !';
            var expected = '--------------------------------------';
            var result = source.pipe(operators_1.retry());
            expectObservable(result, unsub).toBe(expected);
        });
    });
    it('should handle a basic source that emits next then completes', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = hot('--1--2--^--3--4--5---|');
            var subs = '^            !';
            var expected = '---3--4--5---|';
            var result = source.pipe(operators_1.retry());
            expectObservable(result).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    it('should handle a basic source that emits next but does not complete', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = hot('--1--2--^--3--4--5---');
            var subs = '^            ';
            var expected = '---3--4--5---';
            var result = source.pipe(operators_1.retry());
            expectObservable(result).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    it('should handle a basic source that emits next then errors, no count', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = cold('--1-2-3-#');
            var unsub = '^------------------------------------!';
            var subs = ['^       !                             ',
                '        ^       !                     ',
                '                ^       !             ',
                '                        ^       !     ',
                '                                ^    !'];
            var expected = '--1-2-3---1-2-3---1-2-3---1-2-3---1-2-';
            var result = source.pipe(operators_1.retry());
            expectObservable(result, unsub).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    it('should handle a source which eventually throws, count=3, and result is ' +
        'unsubscribed early', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = cold('--1-2-3-#');
            var unsub = '^------------!           ';
            var subs = ['^       !                ',
                '        ^    !           '];
            var expected = '--1-2-3---1-2-';
            var result = source.pipe(operators_1.retry(3));
            expectObservable(result, unsub).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    it('should not break unsubscription chain when unsubscribed explicitly', function () {
        testScheduler.run(function (_a) {
            var cold = _a.cold, hot = _a.hot, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var source = cold('--1-2-3-#');
            var subs = ['^       !                ',
                '        ^    !           '];
            var expected = '--1-2-3---1-2-';
            var unsub = '^------------!           ';
            var result = source.pipe(operators_1.mergeMap(function (x) { return rxjs_1.of(x); }), operators_1.retry(100), operators_1.mergeMap(function (x) { return rxjs_1.of(x); }));
            expectObservable(result, unsub).toBe(expected);
            expectSubscriptionsTo(source).toBe(subs);
        });
    });
    // it('should retry a synchronous source (multicasted and refCounted) multiple times', done => {
    //   const expected = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3];
    //   of(1, 2, 3).pipe(
    //     concat(throwError('bad!')),
    //     multicast(() => new Subject()),
    //     refCount(),
    //     retry(4)
    //   ).subscribe(
    //       x => { expect(x).to.equal(expected.shift()); },
    //       (err: any) => {
    //         expect(err).to.equal('bad!');
    //         expect(expected.length).to.equal(0);
    //         done();
    //       }, () => {
    //         done(new Error('should not be called'));
    //       });
    // });
});
//# sourceMappingURL=retry-spec.js.map