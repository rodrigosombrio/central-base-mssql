"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("rxjs/internal/Observable");
var Subscription_1 = require("rxjs/internal/Subscription");
var VirtualTimeScheduler_1 = require("rxjs/internal/scheduler/VirtualTimeScheduler");
var isObservable_1 = require("rxjs/internal/util/isObservable");
var asyncScheduler_1 = require("rxjs/internal/scheduler/asyncScheduler");
var asapScheduler_1 = require("rxjs/internal/scheduler/asapScheduler");
var QueueScheduler_1 = require("rxjs/internal/scheduler/QueueScheduler");
var Subject_1 = require("../Subject");
var Notification_1 = require("../Notification");
// TODO(benlesh): we need to figure out how to have TestScheduler support testing
// the animation frame scheduler
function createSchedulerPatch(scheduler) {
    return {
        _schedule: null,
        _now: null,
        _patched: false,
        patch: function (testScheduler) {
            if (!this._patched) {
                this._patched = true;
                this._schedule = scheduler.schedule;
                this._now = scheduler.now;
                scheduler.schedule = testScheduler.schedule.bind(testScheduler);
                scheduler.now = testScheduler.now.bind(testScheduler);
            }
        },
        unpatch: function () {
            if (this._patched) {
                scheduler.schedule = this._schedule;
                scheduler.now = this._now;
            }
            this._patched = false;
        }
    };
}
// Since the queue flushes synchronously, and any delay over 0 is pushed through
// the asyncScheduler, which is already patched, queueScheduler only needs to patch
// the now function.
var QUEUE_SCHEDULER_PATCH = {
    _now: null,
    _patched: false,
    patch: function (testScheduler) {
        if (!this._patched) {
            this._patched = true;
            this._now = QueueScheduler_1.QueueScheduler.prototype.now;
            QueueScheduler_1.QueueScheduler.prototype.now = testScheduler.now.bind(testScheduler);
        }
    },
    unpatch: function () {
        if (this._patched) {
            QueueScheduler_1.QueueScheduler.prototype.now = this._now;
        }
        this._patched = false;
    }
};
var DEFAULT_SCHEDULER_PATCHES = [
    createSchedulerPatch(asyncScheduler_1.asyncScheduler),
    createSchedulerPatch(asapScheduler_1.asapScheduler),
    QUEUE_SCHEDULER_PATCH,
];
var FRAME_TIME_FACTOR = 1;
var TestObservable = /** @class */ (function (_super) {
    __extends(TestObservable, _super);
    function TestObservable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.subscriptions = [];
        _this.messages = [];
        return _this;
    }
    return TestObservable;
}(Observable_1.Observable));
exports.TestObservable = TestObservable;
var TestScheduler = /** @class */ (function (_super) {
    __extends(TestScheduler, _super);
    function TestScheduler(_assertDeepEqual) {
        var _this = _super.call(this) || this;
        _this._assertDeepEqual = _assertDeepEqual;
        _this._runMode = false;
        _this._flushTests = [];
        _this._patches = DEFAULT_SCHEDULER_PATCHES;
        _this._hotObservables = [];
        _this._coldObservables = [];
        return _this;
    }
    TestScheduler.prototype._materializeInnerObservable = function (observable, outerFrame) {
        var _this = this;
        var messages = [];
        observable.subscribe({
            next: function (value) {
                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });
            },
            error: function (error) {
                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(error) });
            },
            complete: function () {
                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });
            }
        });
        return messages;
    };
    TestScheduler.prototype.createTime = function (marbles) {
        var indexOf = marbles.indexOf('|');
        if (indexOf === -1) {
            throw new Error('marble diagram for time should have a completion marker "|"');
        }
        return indexOf * this.frameTimeFactor;
    };
    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
        if (marbles.indexOf('^') !== -1) {
            throw new Error('cold observable cannot have subscription offset "^"');
        }
        if (marbles.indexOf('!') !== -1) {
            throw new Error('cold observable cannot have unsubscription marker "!"');
        }
        var messages = parseMarbles(marbles, values, error, undefined, this._runMode);
        var cold = coldObservable(messages, this);
        this._coldObservables.push(cold);
        return cold;
    };
    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
        if (marbles.indexOf('!') !== -1) {
            throw new Error('hot observable cannot have unsubscription marker "!"');
        }
        var messages = parseMarbles(marbles, values, error, undefined, this._runMode);
        var subject = hotObservable(messages, this);
        this._hotObservables.push(subject);
        return subject;
    };
    TestScheduler.prototype.expectObservable = function (observable, subscriptionMarbles) {
        var _this = this;
        if (subscriptionMarbles === void 0) { subscriptionMarbles = null; }
        var actual = [];
        var flushTest = { actual: actual, ready: false };
        var subscriptionParsed = parseMarblesAsSubscriptions(subscriptionMarbles, this._runMode);
        var subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?
            0 : subscriptionParsed.subscribedFrame;
        var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
        var subscription;
        this.schedule(function () {
            subscription = observable.subscribe({
                next: function (x) {
                    var value = x;
                    // Support Observable-of-Observables
                    if (isObservable_1.isObservable(x)) {
                        value = _this._materializeInnerObservable(x, _this.frame);
                    }
                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });
                },
                error: function (error) {
                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(error) });
                },
                complete: function () {
                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });
                }
            });
        }, subscriptionFrame);
        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
        }
        this._flushTests.push(flushTest);
        return {
            toBe: function (marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.expected = parseMarbles(marbles, values, errorValue, true, _this._runMode);
            }
        };
    };
    TestScheduler.prototype.expectSubscriptionsTo = function (observable) {
        var _this = this;
        var actual = [];
        var flushTest = { actual: actual, ready: false };
        this.schedule(function () {
            observable.subscriptions.map(function (log) {
                actual.push(log);
            });
        }, 0);
        return {
            toBe: function (marbles) {
                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
                flushTest.ready = true;
                flushTest.expected = marblesArray.map(function (marbles) {
                    return parseMarblesAsSubscriptions(marbles, _this._runMode);
                });
            }
        };
    };
    TestScheduler.prototype.run = function (callback) {
        var _this = this;
        var prevMaxFrames = this.maxFrames;
        this.maxFrames = Number.POSITIVE_INFINITY;
        this._runMode = true;
        var patches = this._patches;
        // Patch the schedulers
        patches.forEach(function (patch) { return patch.patch(_this); });
        var helpers = {
            cold: this.createColdObservable.bind(this),
            hot: this.createHotObservable.bind(this),
            flush: this.flush.bind(this),
            expectObservable: this.expectObservable.bind(this),
            expectSubscriptionsTo: this.expectSubscriptionsTo.bind(this),
            time: this.createTime.bind(this),
        };
        try {
            var ret = callback(helpers);
            this.flush();
            return ret;
        }
        finally {
            this.maxFrames = prevMaxFrames;
            this._runMode = false;
            // Unpatch the schedulers
            patches.forEach(function (patch) { return patch.unpatch(); });
        }
    };
    TestScheduler.prototype.flush = function () {
        var _this = this;
        var hotObservables = this._hotObservables;
        while (hotObservables.length > 0) {
            hotObservables.shift().setup();
        }
        _super.prototype.flush.call(this);
        this._flushTests = this._flushTests.filter(function (test) {
            if (test.ready) {
                // console.log(JSON.stringify(test.actual, null, 2));
                // console.log(JSON.stringify(test.expected, null, 2));
                _this._assertDeepEqual(test.actual, test.expected);
                return false;
            }
            return true;
        });
    };
    return TestScheduler;
}(VirtualTimeScheduler_1.VirtualTimeScheduler));
exports.TestScheduler = TestScheduler;
function subscriptionLogger() {
    return {
        logSubscription: function (frame) {
            var logs = this.logs;
            logs.push(subscriptionLog(frame));
            return logs.length - 1;
        },
        logUnsubscription: function (index, frame) {
            this.logs[index].unsubscribedFrame = frame;
        },
        logs: [],
    };
}
exports.subscriptionLogger = subscriptionLogger;
function subscriptionLog(subscribedFrame, unsubscribedFrame) {
    if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }
    return {
        subscribedFrame: subscribedFrame,
        unsubscribedFrame: unsubscribedFrame,
    };
}
exports.subscriptionLog = subscriptionLog;
function parseMarblesAsSubscriptions(marbles, runMode) {
    if (runMode === void 0) { runMode = false; }
    if (typeof marbles !== 'string') {
        return subscriptionLog(Number.POSITIVE_INFINITY);
    }
    var len = marbles.length;
    var groupStart = -1;
    var subscriptionFrame = Number.POSITIVE_INFINITY;
    var unsubscriptionFrame = Number.POSITIVE_INFINITY;
    var frame = 0;
    var _loop_1 = function (i) {
        var nextFrame = frame;
        var advanceFrameBy = function (count) {
            nextFrame += count * FRAME_TIME_FACTOR;
        };
        var c = marbles[i];
        switch (c) {
            case ' ':
                // Whitespace no longer advances time
                if (!runMode) {
                    advanceFrameBy(1);
                }
                break;
            case '-':
                advanceFrameBy(1);
                break;
            case '(':
                groupStart = frame;
                advanceFrameBy(1);
                break;
            case ')':
                groupStart = -1;
                advanceFrameBy(1);
                break;
            case '^':
                if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
                    throw new Error('found a second subscription point \'^\' in a ' +
                        'subscription marble diagram. There can only be one.');
                }
                subscriptionFrame = groupStart > -1 ? groupStart : frame;
                advanceFrameBy(1);
                break;
            case '!':
                if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
                    throw new Error('found a second subscription point \'^\' in a ' +
                        'subscription marble diagram. There can only be one.');
                }
                unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                break;
            default:
                // time progression syntax
                if (runMode && c.match(/^[0-9]$/)) {
                    // Time progression must be preceeded by at least one space
                    // if it's not at the beginning of the diagram
                    if (i === 0 || marbles[i - 1] === ' ') {
                        var buffer = marbles.slice(i);
                        var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                        if (match) {
                            i += match[0].length - 1;
                            // tslint:disable-next-line:ban
                            var duration = parseFloat(match[1]);
                            var unit = match[2];
                            var durationInMs = void 0;
                            switch (unit) {
                                case 'ms':
                                    durationInMs = duration;
                                    break;
                                case 's':
                                    durationInMs = duration * 1000;
                                    break;
                                case 'm':
                                    durationInMs = duration * 1000 * 60;
                                    break;
                                default:
                                    break;
                            }
                            advanceFrameBy(durationInMs / FRAME_TIME_FACTOR);
                            break;
                        }
                    }
                }
                throw new Error('there can only be \'^\' and \'!\' markers in a ' +
                    'subscription marble diagram. Found instead \'' + c + '\'.');
        }
        frame = nextFrame;
        out_i_1 = i;
    };
    var out_i_1;
    for (var i = 0; i < len; i++) {
        _loop_1(i);
        i = out_i_1;
    }
    if (unsubscriptionFrame < 0) {
        return subscriptionLog(subscriptionFrame);
    }
    else {
        return subscriptionLog(subscriptionFrame, unsubscriptionFrame);
    }
}
exports.parseMarblesAsSubscriptions = parseMarblesAsSubscriptions;
function isTestObservable(value) {
    return isObservable_1.isObservable(value) && Array.isArray(value.subscriptions);
}
function parseMarbles(marbles, values, errorValue, materializeInnerObservables, runMode) {
    if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
    if (runMode === void 0) { runMode = false; }
    if (marbles.indexOf('!') !== -1) {
        throw new Error('conventional marble diagrams cannot have the ' +
            'unsubscription marker "!"');
    }
    var len = marbles.length;
    var testMessages = [];
    var subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');
    var frame = subIndex === -1 ? 0 : (subIndex * -FRAME_TIME_FACTOR);
    var getValue = !values ?
        function (x) { return x; } :
        function (x) {
            // Support Observable-of-Observables
            var value = values[x];
            if (materializeInnerObservables && isTestObservable(value)) {
                return value.messages;
            }
            return value;
        };
    var groupStart = -1;
    var _loop_2 = function (i) {
        var nextFrame = frame;
        var advanceFrameBy = function (count) {
            nextFrame += count * FRAME_TIME_FACTOR;
        };
        var notification = void 0;
        var c = marbles[i];
        switch (c) {
            case ' ':
                // Whitespace no longer advances time
                if (!runMode) {
                    advanceFrameBy(1);
                }
                break;
            case '-':
                advanceFrameBy(1);
                break;
            case '(':
                groupStart = frame;
                advanceFrameBy(1);
                break;
            case ')':
                groupStart = -1;
                advanceFrameBy(1);
                break;
            case '|':
                notification = Notification_1.Notification.createComplete();
                advanceFrameBy(1);
                break;
            case '^':
                advanceFrameBy(1);
                break;
            case '#':
                notification = Notification_1.Notification.createError(errorValue || 'error');
                advanceFrameBy(1);
                break;
            default:
                // Might be time progression syntax, or a value literal
                if (runMode && c.match(/^[0-9]$/)) {
                    // Time progression must be preceeded by at least one space
                    // if it's not at the beginning of the diagram
                    if (i === 0 || marbles[i - 1] === ' ') {
                        var buffer = marbles.slice(i);
                        var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                        if (match) {
                            i += match[0].length - 1;
                            var duration = parseFloat(match[1]);
                            var unit = match[2];
                            var durationInMs = void 0;
                            switch (unit) {
                                case 'ms':
                                    durationInMs = duration;
                                    break;
                                case 's':
                                    durationInMs = duration * 1000;
                                    break;
                                case 'm':
                                    durationInMs = duration * 1000 * 60;
                                    break;
                                default:
                                    break;
                            }
                            advanceFrameBy(durationInMs / FRAME_TIME_FACTOR);
                            break;
                        }
                    }
                }
                notification = Notification_1.Notification.createNext(getValue(c));
                advanceFrameBy(1);
                break;
        }
        if (notification) {
            testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
        }
        frame = nextFrame;
        out_i_2 = i;
    };
    var out_i_2;
    for (var i = 0; i < len; i++) {
        _loop_2(i);
        i = out_i_2;
    }
    return testMessages;
}
exports.parseMarbles = parseMarbles;
function scheduleNotifications(scheduler, messages, subject, subs) {
    scheduler.schedule(function () {
        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
            var message = messages_1[_i];
            var t = void 0;
            var a = undefined;
            var notification = message.notification, frame = message.frame;
            if (notification.kind === 'N') {
                t = 1 /* NEXT */;
                a = notification.value;
            }
            else if (notification.kind === 'E') {
                t = 3 /* ERROR */;
                a = notification.error;
            }
            else if (notification.kind === 'C') {
                t = 2 /* COMPLETE */;
            }
            else {
                continue;
            }
            scheduler.schedule(function (_a) {
                var t = _a.t, a = _a.a, subs = _a.subs;
                return subject(t, a, subs);
            }, frame, { t: t, a: a, subs: subs });
        }
    });
}
exports.scheduleNotifications = scheduleNotifications;
function hotObservable(messages, scheduler) {
    var subsLogger = subscriptionLogger();
    var result = new Subject_1.Subject();
    var _subscribe = result.subscribe;
    result.subscribe = function () {
        var subsLogIndex = subsLogger.logSubscription(scheduler.now());
        var subs = new Subscription_1.Subscription();
        subs.add(function () { return subsLogger.logUnsubscription(subsLogIndex, scheduler.now()); });
        subs.add(_subscribe.apply(result, arguments));
        return subs;
    };
    result.subscriptions = subsLogger.logs;
    result.messages = messages;
    result.setup = function () {
        var subs = new Subscription_1.Subscription();
        scheduler.schedule(function () {
            var _loop_3 = function (frame, notification) {
                subs.add(scheduler.schedule(function () {
                    notification.observe(result);
                }, frame));
            };
            for (var _i = 0, messages_2 = messages; _i < messages_2.length; _i++) {
                var _a = messages_2[_i], frame = _a.frame, notification = _a.notification;
                _loop_3(frame, notification);
            }
        });
    };
    return result;
}
exports.hotObservable = hotObservable;
function coldObservable(messages, scheduler) {
    var subsLogger = subscriptionLogger();
    var result = new Observable_1.Observable(function (subscriber) {
        var subsLogIndex = subsLogger.logSubscription(scheduler.now());
        var subs = new Subscription_1.Subscription();
        subs.add(function () { return subsLogger.logUnsubscription(subsLogIndex, scheduler.now()); });
        subs.add(scheduler.schedule(function () {
            var _loop_4 = function (message) {
                var notification = message.notification, frame = message.frame;
                subs.add(scheduler.schedule(function () {
                    notification.observe(subscriber);
                }, frame));
            };
            for (var _i = 0, messages_3 = messages; _i < messages_3.length; _i++) {
                var message = messages_3[_i];
                _loop_4(message);
            }
        }));
        return subs;
    });
    result.subscriptions = subsLogger.logs;
    result.messages = messages;
    return result;
}
exports.coldObservable = coldObservable;
//# sourceMappingURL=TestScheduler.js.map