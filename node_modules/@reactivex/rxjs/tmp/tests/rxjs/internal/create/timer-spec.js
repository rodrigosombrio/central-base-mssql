"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var rxjs_1 = require("rxjs");
var testing_1 = require("rxjs/testing");
var operators_1 = require("rxjs/operators");
var assertDeepEquals_1 = require("rxjs/internal/test_helpers/assertDeepEquals");
/** @test {timer} */
describe('timer', function () {
    var testScheduler;
    beforeEach(function () {
        testScheduler = new testing_1.TestScheduler(assertDeepEquals_1.assertDeepEquals);
    });
    //asDiagram('timer(3000, 1000)')
    it('should create an observable emitting periodically', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var e1 = rxjs_1.timer(6, 2, testScheduler).pipe(operators_1.take(4), // make it actually finite, so it can be rendered
            operators_1.concatWith(rxjs_1.NEVER) // but pretend it's infinite by not completing
            );
            var expected = '------a-b-c-d-';
            var values = {
                a: 0,
                b: 1,
                c: 2,
                d: 3,
            };
            expectObservable(e1).toBe(expected, values);
        });
    });
    it('should schedule a value of 0 then complete', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var dueTime = time('-----|');
            var expected = '-----(x|)';
            var source = rxjs_1.timer(dueTime, undefined, testScheduler);
            expectObservable(source).toBe(expected, { x: 0 });
        });
    });
    it('should emit a single value immediately', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var dueTime = time('|');
            var expected = '(x|)';
            var source = rxjs_1.timer(dueTime, testScheduler);
            expectObservable(source).toBe(expected, { x: 0 });
        });
    });
    it('should start after delay and periodically emit values', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var dueTime = time('----|');
            var period = time('--|');
            var expected = '----a-b-c-d-(e|)';
            var source = rxjs_1.timer(dueTime, period, testScheduler).pipe(operators_1.take(5));
            var values = { a: 0, b: 1, c: 2, d: 3, e: 4 };
            expectObservable(source).toBe(expected, values);
        });
    });
    it('should start immediately and periodically emit values', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var dueTime = time('|');
            var period = time('---|');
            var expected = 'a--b--c--d--(e|)';
            var source = rxjs_1.timer(dueTime, period, testScheduler).pipe(operators_1.take(5));
            var values = { a: 0, b: 1, c: 2, d: 3, e: 4 };
            expectObservable(source).toBe(expected, values);
        });
    });
    it('should stop emiting values when subscription is done', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var dueTime = time('|');
            var period = time('---|');
            var expected = 'a--b--c--d--e';
            var unsub = '^------------!';
            var source = rxjs_1.timer(dueTime, period, testScheduler);
            var values = { a: 0, b: 1, c: 2, d: 3, e: 4 };
            expectObservable(source, unsub).toBe(expected, values);
        });
    });
    it('should schedule a value at a specified Date', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var offset = time('----|');
            var expected = '----(a|)';
            var dueTime = new Date(testScheduler.now() + offset);
            var source = rxjs_1.timer(dueTime, null, testScheduler);
            expectObservable(source).toBe(expected, { a: 0 });
        });
    });
    it('should start after delay and periodically emit values', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var offset = time('----|');
            var period = time('--|');
            var expected = '----a-b-c-d-(e|)';
            var dueTime = new Date(testScheduler.now() + offset);
            var source = rxjs_1.timer(dueTime, period, testScheduler).pipe(operators_1.take(5));
            var values = { a: 0, b: 1, c: 2, d: 3, e: 4 };
            expectObservable(source).toBe(expected, values);
        });
    });
    it('should still target the same date if a date is provided even for the ' +
        'second subscription', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo, time = _a.time;
            var offset = time('----|    ');
            var t1 = cold('a|       ');
            var t2 = cold('--a|     ');
            var expected = '----(aa|)';
            var dueTime = new Date(testScheduler.now() + offset);
            var source = rxjs_1.timer(dueTime, null, testScheduler);
            var testSource = rxjs_1.merge(t1, t2).pipe(operators_1.mergeMap(function () { return source; }));
            expectObservable(testSource).toBe(expected, { a: 0 });
        });
    });
});
//# sourceMappingURL=timer-spec.js.map