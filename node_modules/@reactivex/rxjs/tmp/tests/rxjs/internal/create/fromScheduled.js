"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArrayLike_1 = require("rxjs/internal/util/isArrayLike");
var Observable_1 = require("rxjs/internal/Observable");
var Subscription_1 = require("rxjs/internal/Subscription");
var isIterable_1 = require("rxjs/internal/util/isIterable");
var isObservable_1 = require("rxjs/internal/util/isObservable");
var isInteropObservable_1 = require("rxjs/internal/util/isInteropObservable");
var isPromiseLike_1 = require("rxjs/internal/util/isPromiseLike");
var isAsyncIterable_1 = require("rxjs/internal/util/isAsyncIterable");
var symbolAsyncIterator_1 = require("rxjs/internal/util/symbolAsyncIterator");
function fromScheduled(input, scheduler) {
    if (isObservable_1.isObservable(input)) {
        return fromObservableScheduled(input, scheduler);
    }
    else if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input, scheduler);
    }
    else if (isPromiseLike_1.isPromiseLike(input)) {
        return fromPromiseLike(input, scheduler);
    }
    else if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input, scheduler);
    }
    else if (isIterable_1.isIterable(input)) {
        return fromIterableScheduled(input, scheduler);
    }
    else if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLikeScheduled(input, scheduler);
    }
    else {
        throw new Error('not implemented yet');
    }
}
exports.fromScheduled = fromScheduled;
// TODO: this could be refactored with subscribeOn and observeOn (perhaps "scheduleOn")?
function fromObservableScheduled(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        scheduler.schedule(function () {
            var subscription = new Subscription_1.Subscription();
            subscription.add(input.subscribe({
                next: function (value) { return scheduler.schedule(function () { return subscriber.next(value); }, 0, null, subscription); },
                error: function (err) { return scheduler.schedule(function () { return subscriber.error(err); }, 0, null, subscription); },
                complete: function () { return scheduler.schedule(function () { return subscriber.complete(); }, 0, null, subscription); },
            }));
            return subscription;
        });
    });
}
function fromInteropObservable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        scheduler.schedule(function () {
            var source = input[Symbol.observable]();
            var innerSubs = source.subscribe({
                next: function (value) {
                    scheduler.schedule(function () { return subscriber.next(value); }, 0, null, subscription);
                },
                error: function (err) {
                    scheduler.schedule(function () { return subscriber.error(err); }, 0, null, subscription);
                },
                complete: function () {
                    scheduler.schedule(function () { return subscriber.complete(); }, 0, null, subscription);
                }
            });
            subscription.add(innerSubs);
        }, 0, null, subscription);
        return subscription;
    });
}
function fromPromiseLike(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        scheduler.schedule(function () {
            input.then(function (value) {
                scheduler.schedule(function () {
                    subscriber.next(value);
                    scheduler.schedule(function () { return subscriber.complete(); }, 0, null, subscription);
                }, 0, null, subscription);
            }, function (err) {
                scheduler.schedule(function () { return subscriber.error(err); }, 0, null, subscription);
            });
        }, 0, null, subscription);
        return subscription;
    });
}
function fromAsyncIterable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        scheduler.schedule(function () {
            var ai = input[symbolAsyncIterator_1.symbolAsyncIterator]();
            var go = function () { return scheduler.schedule(function () {
                ai.next().then(function (result) {
                    var done = result.done, value = result.value;
                    if (done) {
                        scheduler.schedule(function () { return subscriber.complete(); }, 0, null, subscription);
                    }
                    else {
                        scheduler.schedule(function () { return subscriber.next(value); }, 0, null, subscription);
                        go();
                    }
                }, function (err) {
                    scheduler.schedule(function () { return subscriber.error(err); }, 0, null, subscription);
                });
            }, 0, null, subscription); };
            go();
        }, 0, null, subscription);
        return subscription;
    });
}
function fromArrayLikeScheduled(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var i = 0;
        scheduler.schedule(fromArrayLikeWork, 0, { i: i, input: input, subscription: subscription, subscriber: subscriber, scheduler: scheduler }, subscription);
        return subscription;
    });
}
function fromArrayLikeWork(state) {
    var i = state.i, input = state.input, subs = state.subscription, subscriber = state.subscriber, scheduler = state.scheduler;
    if (subs.closed) {
        return;
    }
    if (i < input.length) {
        if (i < input.length) {
            subscriber.next(input[state.i++]);
            if (subs.closed) {
                return;
            }
            scheduler.schedule(fromArrayLikeWork, 0, state, subs);
        }
        else {
            subscriber.complete();
        }
    }
}
function fromIterableScheduled(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var iterator = input[Symbol.iterator]();
        scheduler.schedule(fromIterableWork, 0, { iterator: iterator, subscription: subscription, subscriber: subscriber, scheduler: scheduler }, subscription);
        return subscription;
    });
}
function fromIterableWork(state) {
    var iterator = state.iterator, subscription = state.subscription, subscriber = state.subscriber, scheduler = state.scheduler;
    if (subscription.closed) {
        return;
    }
    var _a = iterator.next(), done = _a.done, value = _a.value;
    if (done) {
        subscriber.complete();
    }
    else {
        subscriber.next(value);
        scheduler.schedule(fromIterableWork, 0, state, subscription);
    }
}
//# sourceMappingURL=fromScheduled.js.map