"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var rxjs_1 = require("rxjs");
var testing_1 = require("rxjs/testing");
var operators_1 = require("rxjs/operators");
var sinon = require("sinon");
var assertDeepEquals_1 = require("../test_helpers/assertDeepEquals");
/** @test {interval} */
describe('interval', function () {
    var testScheduler;
    beforeEach(function () {
        testScheduler = new testing_1.TestScheduler(assertDeepEquals_1.assertDeepEquals);
    });
    //asDiagram('interval(1000)')
    it('should create an observable emitting periodically', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var e1 = rxjs_1.interval(2, testScheduler).pipe(operators_1.take(6), // make it actually finite, so it can be rendered
            operators_1.concatWith(rxjs_1.NEVER) // but pretend it's infinite by not completing
            );
            var expected = '--a-b-c-d-e-f-';
            var values = {
                a: 0,
                b: 1,
                c: 2,
                d: 3,
                e: 4,
                f: 5,
            };
            expectObservable(e1).toBe(expected, values);
        });
    });
    it('should set up an interval', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var expected = '----------0---------1---------2---------3---------4---------5---------6-----';
            var subs = '^--------------------------------------------------------------------------!';
            expectObservable(rxjs_1.interval(10, testScheduler), subs).toBe(expected, [0, 1, 2, 3, 4, 5, 6]);
        });
    });
    it('should emit when relative interval set to zero', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var e1 = rxjs_1.interval(0, testScheduler).pipe(operators_1.take(7));
            var expected = '(0123456|)';
            expectObservable(e1).toBe(expected, [0, 1, 2, 3, 4, 5, 6]);
        });
    });
    it('should consider negative interval as zero', function () {
        testScheduler.run(function (_a) {
            var hot = _a.hot, cold = _a.cold, expectObservable = _a.expectObservable, expectSubscriptionsTo = _a.expectSubscriptionsTo;
            var e1 = rxjs_1.interval(-1, testScheduler).pipe(operators_1.take(7));
            var expected = '(0123456|)';
            expectObservable(e1).toBe(expected, [0, 1, 2, 3, 4, 5, 6]);
        });
    });
    it('should emit values until unsubscribed', function (done) {
        var values = [];
        var expected = [0, 1, 2, 3, 4, 5, 6];
        var e1 = rxjs_1.interval(5);
        var subscription = e1.subscribe({
            next: function (x) {
                values.push(x);
                if (x === 6) {
                    subscription.unsubscribe();
                    chai_1.expect(values).to.deep.equal(expected);
                    done();
                }
            },
            error: function () {
                done(new Error('should not be called'));
            },
            complete: function () {
                done(new Error('should not be called'));
            }
        });
    });
    it('should create an observable emitting periodically with the AsapScheduler', function (done) {
        var sandbox = sinon.createSandbox();
        var fakeTimer = sandbox.useFakeTimers();
        var period = 10;
        var events = [0, 1, 2, 3, 4, 5];
        var source = rxjs_1.interval(period, rxjs_1.asapScheduler).pipe(operators_1.take(6));
        source.subscribe({
            next: function (x) {
                chai_1.expect(x).to.equal(events.shift());
            },
            error: function (e) {
                sandbox.restore();
                done(e);
            },
            complete: function () {
                sandbox.restore();
                done();
            }
        });
        var i = -1, n = events.length;
        while (++i < n) {
            fakeTimer.tick(period);
        }
    });
    it('should create an observable emitting periodically with the QueueScheduler', function (done) {
        var sandbox = sinon.createSandbox();
        var fakeTimer = sandbox.useFakeTimers();
        var period = 10;
        var events = [0, 1, 2, 3, 4, 5];
        var source = rxjs_1.interval(period, rxjs_1.queueScheduler).pipe(operators_1.take(6));
        source.subscribe({
            next: function (x) {
                chai_1.expect(x).to.equal(events.shift());
            },
            error: function (e) {
                sandbox.restore();
                done(e);
            },
            complete: function () {
                sandbox.restore();
                done();
            }
        });
        var i = -1, n = events.length;
        while (++i < n) {
            fakeTimer.tick(period);
        }
    });
    // TODO: Find better stubs for testing rAF in Node
    // it('should create an observable emitting periodically with the AnimationFrameScheduler', done => {
    //   const sandbox = sinon.createSandbox();
    //   const fakeTimer = sandbox.useFakeTimers();
    //   const period = 10;
    //   const events = [0, 1, 2, 3, 4, 5];
    //   const source = interval(period, animationFrameScheduler).pipe(take(6));
    //   source.subscribe({
    //     next(x) {
    //       expect(x).to.equal(events.shift());
    //     },
    //     error(e) {
    //       sandbox.restore();
    //       done(e);
    //     },
    //     complete() {
    //       sandbox.restore();
    //       done();
    //     }
    //   });
    //   let i = -1, n = events.length;
    //   while (++i < n) {
    //     fakeTimer.tick(period);
    //   }
    // });
});
//# sourceMappingURL=interval-spec.js.map