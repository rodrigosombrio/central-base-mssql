"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var rxjs_1 = require("rxjs");
var testing_1 = require("rxjs/testing");
var symbolObservable_1 = require("rxjs/internal/util/symbolObservable");
var symbolAsyncIterator_1 = require("rxjs/internal/util/symbolAsyncIterator");
describe('fromScheduled', function () {
    var testScheduler;
    var _symbolObservableOrig;
    var _existingAsyncIterator = Symbol.asyncIterator;
    before(function () {
        var counter = 0;
        _symbolObservableOrig = Symbol && Symbol.observable;
        Symbol = Symbol || function (desc) { return '' + (counter++); };
        Symbol.observable = Symbol.observable || symbolObservable_1.symbolObservable;
        if (!_existingAsyncIterator) {
            Symbol = Symbol || function (desc) { return '' + (counter++); };
            Symbol.asyncIterator = Symbol.asyncIterator || symbolAsyncIterator_1.symbolAsyncIterator;
        }
    });
    after(function () {
        Symbol.observable = _symbolObservableOrig;
        if (!_existingAsyncIterator) {
            Symbol.asyncIterator = undefined;
        }
    });
    beforeEach(function () {
        testScheduler = new testing_1.TestScheduler(function (a, b) { chai_1.expect(a).to.deep.equal(b); });
    });
    it('should exist', function () {
        chai_1.expect(rxjs_1.fromScheduled).to.exist;
    });
    it('should handle an array', function () {
        var log = [];
        rxjs_1.fromScheduled([1, 2, 3, 4], testScheduler)
            .subscribe({
            next: function (value) { log.push(value); },
            complete: function () { log.push('done'); }
        });
        chai_1.expect(log).to.deep.equal([]);
        testScheduler.flush();
        chai_1.expect(log).to.deep.equal([1, 2, 3, 4, 'done']);
    });
    it('should handle an iterable', function () {
        var _a;
        var log = [];
        var iterable = (_a = {
                _counter: 0,
                next: function () {
                    if (this._counter < 5) {
                        return { done: false, value: this._counter++ };
                    }
                    else {
                        return { done: true };
                    }
                }
            },
            _a[Symbol.iterator] = function () {
                return this;
            },
            _a);
        rxjs_1.fromScheduled(iterable, testScheduler)
            .subscribe({
            next: function (value) { log.push(value); },
            complete: function () { log.push('done'); }
        });
        chai_1.expect(log).to.deep.equal([]);
        testScheduler.flush();
        chai_1.expect(log).to.deep.equal([0, 1, 2, 3, 4, 'done']);
    });
    it('should handle Observable', function () {
        var log = [];
        var source = rxjs_1.of(1, 2, 3, 4);
        rxjs_1.fromScheduled(source, testScheduler)
            .subscribe({
            next: function (value) { log.push(value); },
            complete: function () { log.push('done'); }
        });
        chai_1.expect(log).to.deep.equal([]);
        testScheduler.flush();
        chai_1.expect(log).to.deep.equal([1, 2, 3, 4, 'done']);
    });
    it('should handle Symbol.observable', function () {
        var _a;
        var unsubscribeCalled = false;
        var logs = [];
        var source = (_a = {
                subscribe: function (observer) {
                    observer.next(1);
                    observer.next(2);
                    observer.next(3);
                    observer.complete();
                    return {
                        unsubscribe: function () {
                            unsubscribeCalled = true;
                        }
                    };
                }
            },
            _a[Symbol.observable] = function () {
                return this;
            },
            _a);
        rxjs_1.fromScheduled(source, testScheduler).subscribe({
            next: function (value) { logs.push(value); },
            complete: function () { logs.push('done'); },
        });
        chai_1.expect(logs).to.deep.equal([]);
        chai_1.expect(unsubscribeCalled).to.be.false;
        testScheduler.flush();
        chai_1.expect(logs).to.deep.equal([1, 2, 3, 'done']);
        chai_1.expect(unsubscribeCalled).to.be.true;
    });
    it('should handle resolved PromiseLikes', function () {
        var logs = [];
        var promiseLike = {
            then: function (resolved, rejected) {
                resolved('test');
                return undefined;
            }
        };
        rxjs_1.fromScheduled(promiseLike, testScheduler).subscribe({
            next: function (value) { logs.push(value); },
            complete: function () { logs.push('done'); },
        });
        chai_1.expect(logs).to.deep.equal([]);
        testScheduler.flush();
        chai_1.expect(logs).to.deep.equal(['test', 'done']);
    });
    it('should handle rejected PromiseLikes', function () {
        var logs = [];
        var promiseLike = {
            then: function (resolved, rejected) {
                rejected('LOL');
                return undefined;
            }
        };
        rxjs_1.fromScheduled(promiseLike, testScheduler).subscribe({
            next: function (value) { logs.push(value); },
            error: function (err) { logs.push(err); },
            complete: function () { logs.push('done'); },
        });
        chai_1.expect(logs).to.deep.equal([]);
        testScheduler.flush();
        chai_1.expect(logs).to.deep.equal(['LOL']);
    });
    it('should handle asyncIterables', function () {
        var _a;
        var logs = [];
        var asyncIterable = (_a = {
                _counter: 0
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.next = function () {
                var _this = this;
                if (this._counter <= 3) {
                    return {
                        then: function (resolve) {
                            resolve({ done: false, value: _this._counter++ });
                        }
                    };
                }
                else {
                    return {
                        then: function (resolve) {
                            resolve({ done: true });
                        }
                    };
                }
            },
            _a);
        rxjs_1.fromScheduled(asyncIterable, testScheduler).subscribe({
            next: function (value) { logs.push(value); },
            complete: function () { logs.push('done'); },
        });
        chai_1.expect(logs).to.deep.equal([]);
        testScheduler.flush();
        chai_1.expect(logs).to.deep.equal([0, 1, 2, 3, 'done']);
    });
    it('should handle errored asyncIterables', function () {
        var _a;
        var logs = [];
        var asyncIterable = (_a = {
                _counter: 0
            },
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            _a.next = function () {
                var _this = this;
                if (this._counter <= 3) {
                    return {
                        then: function (resolve) {
                            resolve({ done: false, value: _this._counter++ });
                        }
                    };
                }
                else {
                    return {
                        then: function (resolve, reject) {
                            reject('LOL');
                        }
                    };
                }
            },
            _a);
        rxjs_1.fromScheduled(asyncIterable, testScheduler).subscribe({
            next: function (value) { logs.push(value); },
            error: function (err) { logs.push(err); },
            complete: function () { logs.push('done'); },
        });
        chai_1.expect(logs).to.deep.equal([]);
        testScheduler.flush();
        chai_1.expect(logs).to.deep.equal([0, 1, 2, 3, 'LOL']);
    });
});
//# sourceMappingURL=fromScheduled-spec.js.map