"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var testing_1 = require("rxjs/testing");
var assertDeepEquals_1 = require("rxjs/internal/test_helpers/assertDeepEquals");
var sinon = require("sinon");
var Subject_1 = require("./Subject");
function expectFullObserver(val) {
    chai_1.expect(val).to.be.a('object');
    chai_1.expect(val.next).to.be.a('function');
    chai_1.expect(val.error).to.be.a('function');
    chai_1.expect(val.complete).to.be.a('function');
    chai_1.expect(val.closed).to.be.a('boolean');
}
/** @test {Observable} */
describe('Observable', function () {
    var testScheduler;
    beforeEach(function () {
        testScheduler = new testing_1.TestScheduler(assertDeepEquals_1.assertDeepEquals);
    });
    it('should be constructed with a subscriber function', function (done) {
        var source = new rxjs_1.Observable(function (subscriber) {
            expectFullObserver(subscriber);
            subscriber.next(1);
            subscriber.complete();
        });
        source.subscribe({
            next: function (x) { return chai_1.expect(x).to.equal(1); },
            complete: done
        });
    });
    it('should send errors thrown in the constructor down the error path', function (done) {
        new rxjs_1.Observable(function () {
            throw new Error('this should be handled');
        })
            .subscribe({
            error: function (err) {
                chai_1.expect(err).to.exist
                    .and.be.instanceof(Error)
                    .and.have.property('message', 'this should be handled');
                done();
            }
        });
    });
    it('should allow empty ctor, which is effectively a never-observable', function () {
        testScheduler.run(function (_a) {
            var expectObservable = _a.expectObservable;
            var result = new rxjs_1.Observable();
            expectObservable(result).toBe('-');
        });
    });
    describe.skip('forEach', function () {
        it('should iterate and return a Promise', function (done) {
            var expected = [1, 2, 3];
            var result = rxjs_1.of(1, 2, 3).forEach(function (x) {
                chai_1.expect(x).to.equal(expected.shift());
            })
                .then(function () {
                done();
            });
            chai_1.expect(result.then).to.be.a('function');
        });
        it('should reject promise when in error', function () {
            return rxjs_1.throwError('bad').forEach(function () {
                throw new Error('should not be called');
            }).then(function () {
                throw new Error('should not complete');
            }, function (err) {
                chai_1.expect(err).to.equal('bad');
            });
        });
        it('should reject promise if nextHandler throws', function (done) {
            var results = [];
            rxjs_1.of(1, 2, 3).forEach(function (x) {
                if (x === 3) {
                    throw new Error('NO THREES!');
                }
                results.push(x);
            })
                .then(function () {
                done(new Error('should not be called'));
            }, function (err) {
                chai_1.expect(err).to.be.an('error', 'NO THREES!');
                chai_1.expect(results).to.deep.equal([1, 2]);
                done();
            });
        });
        it('should handle a synchronous throw from the next handler', function () {
            var expected = 'I told, you Bobby Boucher, threes are the debil!';
            var syncObservable = new rxjs_1.Observable(function (subscriber) {
                subscriber.next(1);
                subscriber.next(2);
                subscriber.next(3);
                subscriber.next(4);
            });
            var results = [];
            return syncObservable.forEach(function (x) {
                results.push(x);
                if (x === 3) {
                    throw expected;
                }
            }).then(function () {
                throw new Error('should not be called');
            }, function (err) {
                results.push(err);
                chai_1.expect(results).to.deep.equal([1, 2, 3, expected]);
            });
        });
        it('should handle an asynchronous throw from the next handler and tear down', function () {
            var expected = new Error('I told, you Bobby Boucher, twos are the debil!');
            var asyncObservable = new rxjs_1.Observable(function (observer) {
                var i = 1;
                var id = setInterval(function () { return observer.next(i++); }, 1);
                return function () {
                    clearInterval(id);
                };
            });
            var results = [];
            return asyncObservable.forEach(function (x) {
                results.push(x);
                if (x === 2) {
                    throw expected;
                }
            }).then(function () {
                throw new Error('should not be called');
            }, function (err) {
                results.push(err);
                chai_1.expect(results).to.deep.equal([1, 2, expected]);
            });
        });
        it('should be cancellable via passed Subscription', function () {
            var source = rxjs_1.of(1, 2, 3, 4);
            var results = [];
            var subs = new rxjs_1.Subscription();
            return source.forEach(function (x) {
                results.push(x);
                if (x === 3) {
                    subs.unsubscribe();
                }
            }, subs)
                .then(function () {
                throw new Error('should not complete');
            }, function (err) {
                chai_1.expect(results).to.deep.equal([1, 2, 3]);
                chai_1.expect(err).to.exist
                    .and.be.instanceof(Error)
                    .and.have.property('message', 'forEach aborted');
            });
        });
        it('should be cancelled if the Subscription is already unsubscribed', function () {
            var source = rxjs_1.of(1, 2, 3, 4);
            var results = [];
            var subs = new rxjs_1.Subscription();
            subs.unsubscribe();
            return source.forEach(function (x) {
                results.push(x);
                if (x === 3) {
                    subs.unsubscribe();
                }
            }, subs)
                .then(function () {
                throw new Error('should not complete');
            }, function (err) {
                chai_1.expect(results).to.deep.equal([]);
                chai_1.expect(err).to.exist
                    .and.be.instanceof(Error)
                    .and.have.property('message', 'forEach aborted');
            });
        });
    });
    describe('subscribe', function () {
        it('should be synchronous', function () {
            var subscribed = false;
            var nexted;
            var completed;
            var source = new rxjs_1.Observable(function (observer) {
                subscribed = true;
                observer.next('wee');
                chai_1.expect(nexted).to.equal('wee');
                observer.complete();
                chai_1.expect(completed).to.be.true;
            });
            chai_1.expect(subscribed).to.be.false;
            var mutatedByNext = false;
            var mutatedByComplete = false;
            source.subscribe({
                next: function (x) {
                    nexted = x;
                    mutatedByNext = true;
                },
                complete: function () {
                    completed = true;
                    mutatedByComplete = true;
                }
            });
            chai_1.expect(mutatedByNext).to.be.true;
            chai_1.expect(mutatedByComplete).to.be.true;
        });
        it('should work if subscribe is called with a Subject', function () {
            var subject = new Subject_1.Subject();
            var results = [];
            subject.subscribe({
                next: function (value) { results.push(value); },
                complete: function () { results.push('done'); },
            });
            var source = new rxjs_1.Observable(function (subscriber) {
                subscriber.next('foo');
                subscriber.complete();
            });
            source.subscribe(subject);
            chai_1.expect(results).to.deep.equal(['foo', 'done']);
        });
        it('should work when subscribe is called with no arguments', function () {
            var source = new rxjs_1.Observable(function (subscriber) {
                subscriber.next('foo');
                subscriber.complete();
            });
            source.subscribe();
        });
        it('should not be unsubscribed when other empty subscription completes', function () {
            var unsubscribeCalled = false;
            var source = new rxjs_1.Observable(function () {
                return function () {
                    unsubscribeCalled = true;
                };
            });
            source.subscribe();
            chai_1.expect(unsubscribeCalled).to.be.false;
            rxjs_1.EMPTY.subscribe();
            chai_1.expect(unsubscribeCalled).to.be.false;
        });
        it('should not be unsubscribed when other subscription with same observer completes', function () {
            var unsubscribeCalled = false;
            var source = new rxjs_1.Observable(function () {
                return function () {
                    unsubscribeCalled = true;
                };
            });
            var observer = {
                next: function () { }
            };
            source.subscribe(observer);
            chai_1.expect(unsubscribeCalled).to.be.false;
            rxjs_1.EMPTY.subscribe(observer);
            chai_1.expect(unsubscribeCalled).to.be.false;
        });
        it('should run unsubscription logic when an error is sent asynchronously and subscribe is called with no arguments', function (done) {
            var sandbox = sinon.createSandbox();
            var fakeTimer = sandbox.useFakeTimers();
            var unsubscribeCalled = false;
            var source = new rxjs_1.Observable(function (observer) {
                var id = setInterval(function () {
                    observer.error(0);
                }, 1);
                return function () {
                    clearInterval(id);
                    unsubscribeCalled = true;
                };
            });
            source.subscribe();
            setTimeout(function () {
                var err;
                var errHappened = false;
                try {
                    chai_1.expect(unsubscribeCalled).to.be.true;
                }
                catch (e) {
                    err = e;
                    errHappened = true;
                }
                finally {
                    if (!errHappened) {
                        done();
                    }
                    else {
                        done(err);
                    }
                }
            }, 100);
            fakeTimer.tick(110);
            sandbox.restore();
        });
        it('should return a Subscription that calls the unsubscribe function returned by the subscriber', function () {
            var unsubscribeCalled = false;
            var source = new rxjs_1.Observable(function () {
                return function () {
                    unsubscribeCalled = true;
                };
            });
            var sub = source.subscribe(function () {
                //noop
            });
            chai_1.expect(sub instanceof rxjs_1.Subscription).to.be.true;
            chai_1.expect(unsubscribeCalled).to.be.false;
            chai_1.expect(sub.unsubscribe).to.be.a('function');
            sub.unsubscribe();
            chai_1.expect(unsubscribeCalled).to.be.true;
        });
        it('should ignore next messages after unsubscription', function (done) {
            var times = 0;
            var subscription = new rxjs_1.Observable(function (observer) {
                var i = 0;
                var id = setInterval(function () {
                    observer.next(i++);
                });
                return function () {
                    clearInterval(id);
                    chai_1.expect(times).to.equal(2);
                    done();
                };
            })
                .pipe(operators_1.tap(function () { return times += 1; }))
                .subscribe(function () {
                if (times === 2) {
                    subscription.unsubscribe();
                }
            });
        });
        it('should ignore error messages after unsubscription', function (done) {
            var times = 0;
            var errorCalled = false;
            var subscription = new rxjs_1.Observable(function (subscriber) {
                var i = 0;
                var id = setInterval(function () {
                    subscriber.next(i++);
                    if (i === 3) {
                        subscriber.error(new Error());
                    }
                });
                return function () {
                    clearInterval(id);
                    chai_1.expect(times).to.equal(2);
                    chai_1.expect(errorCalled).to.be.false;
                    done();
                };
            })
                .pipe(operators_1.tap(function () { return times += 1; }))
                .subscribe({
                next: function () {
                    if (times === 2) {
                        subscription.unsubscribe();
                    }
                },
                error: function () { errorCalled = true; }
            });
        });
        it('should ignore complete messages after unsubscription', function (done) {
            var times = 0;
            var completeCalled = false;
            var subscription = new rxjs_1.Observable(function (observer) {
                var i = 0;
                var id = setInterval(function () {
                    observer.next(i++);
                    if (i === 3) {
                        observer.complete();
                    }
                });
                return function () {
                    clearInterval(id);
                    chai_1.expect(times).to.equal(2);
                    chai_1.expect(completeCalled).to.be.false;
                    done();
                };
            })
                .pipe(operators_1.tap(function () { return times += 1; }))
                .subscribe({
                next: function () {
                    if (times === 2) {
                        subscription.unsubscribe();
                    }
                },
                complete: function () { completeCalled = true; }
            });
        });
        describe('when called with an anonymous observer', function () {
            it('should accept an anonymous observer with just a next function and call the next function in the context' +
                ' of the anonymous observer', function (done) {
                //intentionally not using lambda to avoid typescript's this context capture
                var o = {
                    myValue: 'foo',
                    next: function (x) {
                        chai_1.expect(this.myValue).to.equal('foo');
                        chai_1.expect(x).to.equal(1);
                        done();
                    }
                };
                rxjs_1.of(1).subscribe(o);
            });
            it('should accept an anonymous observer with just an error function and call the error function in the context' +
                ' of the anonymous observer', function (done) {
                //intentionally not using lambda to avoid typescript's this context capture
                var o = {
                    myValue: 'foo',
                    error: function (err) {
                        chai_1.expect(this.myValue).to.equal('foo');
                        chai_1.expect(err).to.equal('bad');
                        done();
                    }
                };
                rxjs_1.throwError('bad').subscribe(o);
            });
            it('should accept an anonymous observer with just a complete function and call the complete function in the' +
                ' context of the anonymous observer', function (done) {
                //intentionally not using lambda to avoid typescript's this context capture
                var o = {
                    myValue: 'foo',
                    complete: function complete() {
                        chai_1.expect(this.myValue).to.equal('foo');
                        done();
                    }
                };
                rxjs_1.EMPTY.subscribe(o);
            });
            it('should accept an anonymous observer with no functions at all', function () {
                chai_1.expect(function () {
                    rxjs_1.EMPTY.subscribe({});
                }).not.to.throw();
            });
            it('should ignore next messages after unsubscription', function (done) {
                var times = 0;
                var subscription = new rxjs_1.Observable(function (observer) {
                    var i = 0;
                    var id = setInterval(function () {
                        observer.next(i++);
                    });
                    return function () {
                        clearInterval(id);
                        chai_1.expect(times).to.equal(2);
                        done();
                    };
                })
                    .pipe(operators_1.tap(function () { return times += 1; }))
                    .subscribe({
                    next: function () {
                        if (times === 2) {
                            subscription.unsubscribe();
                        }
                    }
                });
            });
            it('should ignore error messages after unsubscription', function (done) {
                var times = 0;
                var errorCalled = false;
                var subscription = new rxjs_1.Observable(function (observer) {
                    var i = 0;
                    var id = setInterval(function () {
                        observer.next(i++);
                        if (i === 3) {
                            observer.error(new Error());
                        }
                    });
                    return function () {
                        clearInterval(id);
                        chai_1.expect(times).to.equal(2);
                        chai_1.expect(errorCalled).to.be.false;
                        done();
                    };
                })
                    .pipe(operators_1.tap(function () { return times += 1; }))
                    .subscribe({
                    next: function () {
                        if (times === 2) {
                            subscription.unsubscribe();
                        }
                    },
                    error: function () { errorCalled = true; }
                });
            });
            it('should ignore complete messages after unsubscription', function (done) {
                var times = 0;
                var completeCalled = false;
                var subscription = new rxjs_1.Observable(function (observer) {
                    var i = 0;
                    var id = setInterval(function () {
                        observer.next(i++);
                        if (i === 3) {
                            observer.complete();
                        }
                    });
                    return function () {
                        clearInterval(id);
                        chai_1.expect(times).to.equal(2);
                        chai_1.expect(completeCalled).to.be.false;
                        done();
                    };
                })
                    .pipe(operators_1.tap(function () { return times += 1; }))
                    .subscribe({
                    next: function () {
                        if (times === 2) {
                            subscription.unsubscribe();
                        }
                    },
                    complete: function () { completeCalled = true; }
                });
            });
        });
    });
    describe('pipe', function () {
        it('should exist', function () {
            var source = rxjs_1.of('test');
            chai_1.expect(source.pipe).to.be.a('function');
        });
        it('should pipe multiple operations', function (done) {
            rxjs_1.of('test')
                .pipe(operators_1.map(function (x) { return x + x; }), operators_1.map(function (x) { return x + '!!!'; }))
                .subscribe({
                next: function (x) {
                    chai_1.expect(x).to.equal('testtest!!!');
                },
                complete: done
            });
        });
        it('should return the same observable if there are no arguments', function () {
            var source = rxjs_1.of('test');
            var result = source.pipe();
            chai_1.expect(result).to.equal(source);
        });
    });
    // TODO(benlesh): talk to @cartant about this one.
    // it.only('should not swallow internal errors', () => {
    //   const consoleStub = sinon.stub(console, 'warn');
    //   try {
    //     let source = new Observable<number>(observer => observer.next(42));
    //     for (let i = 0; i < 10000; ++i) {
    //       let base = source;
    //       source = new Observable<number>(observer => base.subscribe(observer));
    //     }
    //     source.subscribe();
    //     expect(consoleStub).to.have.property('called', true);
    //   } finally {
    //     consoleStub.restore();
    //   }
    // });
});
//# sourceMappingURL=Observable-spec.js.map