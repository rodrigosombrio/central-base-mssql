"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("rxjs/internal/Subscription");
var VirtualTimeScheduler = /** @class */ (function () {
    function VirtualTimeScheduler(maxFrames) {
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        this.maxFrames = maxFrames;
        this._flushing = false;
        this._actions = [];
        this.index = -1;
        this.frame = 0;
        this.frameTimeFactor = 1;
    }
    VirtualTimeScheduler.prototype.schedule = function (work, delay, state, subs) {
        if (delay === void 0) { delay = 0; }
        if (state === void 0) { state = undefined; }
        subs = subs || new Subscription_1.Subscription();
        var actions = this._actions;
        var action = {
            index: this.index++,
            delay: this.frame + delay,
            work: work,
            state: state,
            subs: subs,
        };
        subs.add(function () {
            var i = actions.indexOf(action);
            if (i >= 0) {
                actions.splice(i, 1);
            }
        });
        actions.push(action);
        if (actions.length > 1000) {
            debugger;
        }
        actions.sort(sortActions);
        return subs;
    };
    VirtualTimeScheduler.prototype.now = function () {
        return this.frame;
    };
    VirtualTimeScheduler.prototype.flush = function () {
        if (!this._flushing) {
            var actions = this._actions;
            var maxFrames = this.maxFrames;
            this._flushing = true;
            var action = void 0;
            while (action = actions.shift()) {
                // ) && (this.frame = action.delay) <= maxFrames
                if (this.frame > action.delay) {
                    // skip frames that were scheduled in the past. That shouldn't be possible.
                    continue;
                }
                this.frame = action.delay;
                if (this.frame > maxFrames) {
                    break;
                }
                try {
                    action.work(action.state);
                }
                catch (err) {
                    while (actions.length > 0) {
                        actions.shift().subs.unsubscribe();
                    }
                    throw err;
                }
            }
            actions.length = 0;
            this._flushing = false;
        }
    };
    return VirtualTimeScheduler;
}());
exports.VirtualTimeScheduler = VirtualTimeScheduler;
function sortActions(a, b) {
    if (a.delay === b.delay) {
        if (a.index === b.index) {
            return 0;
        }
        else if (a.index > b.index) {
            return 1;
        }
        else {
            return -1;
        }
    }
    else if (a.delay > b.delay) {
        return 1;
    }
    else {
        return -1;
    }
}
//# sourceMappingURL=VirtualTimeScheduler.js.map